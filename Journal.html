<html xmlns='http://www.w3.org/1999/xhtml'><head><meta name='generator' content='http://www.appstafarian.com' /><title>Annotations from Marvin for iOS</title></head><body><h1>Annotations from Marvin for iOS</h1><h2>JavaScript for Web Designers</h2><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Resources</b><br/><blockquote><i>Responsible Responsive Design is a closer look at inclusive front-end development practices, from progressive enhancement to accessibility to performance (</i></blockquote><br/><i>(13. December 2019 17:26)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Resources</b><br/><blockquote><i>Progressive enhancement is a concept we barely touched on, but it formed the foundation for the script we built.</i></blockquote><br/><i>(13. December 2019 17:25)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Resources</b><br/><blockquote><i>When the time comes to look something up, whether it&rsquo;s about capitalization or browser support&mdash;and that time will come, more than once per day&mdash;MDN is the place to do it</i></blockquote><br/><i>(13. December 2019 17:25)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Resources</b><br/><blockquote><i>but now that you know what to look for, there&rsquo;s no substitute for reading code. Take a little time to read through the scripts you&rsquo;ve seen flying around a project at work,</i></blockquote><br/><i>(13. December 2019 17:24)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>A site that fully relies on JavaScript for critical functionality&mdash;a website built on the expectation that JavaScript will always run, no matter what&mdash;is a fragile one. Users&rsquo; browsing conditions can change minute to minute, and we can&rsquo;t plan for&mdash;we can&rsquo;t know&mdash;the ways that our scripts might break down.</i></blockquote><br/><i>(13. December 2019 17:12)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>The web is an unpredictable medium, and we have to plan for that&mdash;when writing JavaScript more so than HTML or CSS, by a wide margin.</i></blockquote><br/><i>(13. December 2019 14:58)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>Scripting behavior in a responsible way isn&rsquo;t always easy. We&rsquo;re standing in for the browser, taking over the user&rsquo;s experience of something as common and predictable as clicking on a link. Done in an unobtrusive way, we&rsquo;re able to create a completely fluid experience&mdash;better, in many ways, than the browser itself could.</i></blockquote><br/><i>(13. December 2019 14:58)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>Luckily, addEventListener gives us information about the user&rsquo;s click event in the form of&mdash;you guessed it&mdash;an object. And just as you might expect, that object contains a number of properties about the event, and methods we can use to control the browser&rsquo;s behavior.</i></blockquote><br/><i>(13. December 2019 14:24)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>DOM events are effectively an API for the activity taking place in a browser. This includes the user&rsquo;s actions, CSS animations, and internal browser events like the point where an image is completely loaded, just to name a few.</i></blockquote><br/><i>(13. December 2019 14:21)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>The idea of starting with something usable and layering JavaScript enhancements over that baseline is called progressive enhancement, and we&rsquo;ll talk more about that in a bit. Right now, we have a script to finish.</i></blockquote><br/><i>(13. December 2019 14:20)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>A better reason to avoid styling in JavaScript is to maintain a separation of behavior and presentation. JavaScript is our &ldquo;behavioral&rdquo; layer the way CSS is our &ldquo;presentational&rdquo; layer, and seldom the twain should meet.</i></blockquote><br/><i>(13. December 2019 14:13)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>Remember that identifiers can&rsquo;t contain hyphens, and since everything is an object (sort of), the DOM references styles in object format as well. Any CSS property that contains a hyphen instead gets camel-cased: margin-left becomes marginLeft, border-radius-top-left becomes borderRadiusTopLeft, and so on</i></blockquote><br/><i>(13. December 2019 14:13)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>One of the built-in methods on all DOM nodes is  appendChild, which&mdash;as the name implies&mdash;allows us to append a child element to that DOM node. W</i></blockquote><br/><i>(13. December 2019 14:09)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>Now we can use two other DOM interfaces to make that link more useful: setAttribute to give it attributes, and innerHTML to populate it with text.</i></blockquote><br/><i>(13. December 2019 14:06)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>Making a single trip to the DOM whenever possible is also better for performance&mdash;but performance micro-optimization is easy to obsess over.</i></blockquote><br/><i>(13. December 2019 14:05)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>We can break this script down into a few discrete tasks: we need to add a Read More link to the first paragraph, we need to hide all the p elements apart from the first one, and we need to reveal those hidden elements when the user interacts with the Read More link.</i></blockquote><br/><i>(13. December 2019 14:04)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>JavaScript&rsquo;s map of the DOM works both ways: document is updated whenever any markup changes, and our markup is updated whenever anything within document changes (FIG 5.1).</i></blockquote><br/><i>(13. December 2019 14:00)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>The same way these methods give us access to information on the rendered page, they allow us to alter that information, as well. For example, the innerHTML method does this the same way we&rsquo;d change the value of any other object:</i></blockquote><br/><i>(13. December 2019 13:59)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>the innerHTML method will return any markup a node contains&mdash;elements, text, and so on&mdash;as a string:</i></blockquote><br/><i>(13. December 2019 13:58)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>But DOM methods don&rsquo;t give us arrays, strictly speaking. Methods like getElementsByTagName return &ldquo;node lists,&rdquo; which behave a lot like arrays. E</i></blockquote><br/><i>(13. December 2019 13:58)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>But window.document isn&apos;t just a representation of the page; it also provides us with a smarter API for accessing that information.</i></blockquote><br/><i>(13. December 2019 13:04)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>DOM&rsquo;s entire representation of the page is a property of window: specifically, window.document</i></blockquote><br/><i>(13. December 2019 13:02)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>hen we introduce a variable to the global scope, we&rsquo;re making it a property of window&mdash;and since we don&rsquo;t explicitly have to reference window whenever we&rsquo;re accessing one of its properties or methods, we can call that variable anywhere in our scripts by just using its identifie</i></blockquote><br/><i>(13. December 2019 13:01)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>window object is that global scope. All of the functions and methods built into JavaScript are built off of the window object.</i></blockquote><br/><i>(13. December 2019 13:00)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>though: the DOM is a representation of a web page in the form of an object, made up of properties that represent each of the document&rsquo;s child elements and subproperties representing each of those elements&rsquo; child elements, and so on. It&rsquo;s objects all the way down.</i></blockquote><br/><i>(13. December 2019 12:59)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 5. DOM Scripting</b><br/><blockquote><i>There are two purposes to the DOM: providing JavaScript with a map of all the elements on our page, and providing us with a set of methods for accessing those elements, their attributes, and their contents.</i></blockquote><br/><i>(13. December 2019 12:59)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>Upon encountering a break, JavaScript reacts the same way it does when it reaches a loop&rsquo;s built-in condition for termination: it stops iterating over the loop completely.</i></blockquote><br/><i>(13. December 2019 12:57)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>the contents of a while loop may never run at all&mdash;as in our random number example above&mdash;but the code in a do/while loop will always execute at least once.</i></blockquote><br/><i>(13. December 2019 12:50)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>We&rsquo;ll use while when we don&rsquo;t have any way of measuring the number of iterations necessary, and instead want to continue to run the loop until a certain condition is met.</i></blockquote><br/><i>(13. December 2019 12:47)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>But even more importantly&mdash;at least, for the sake of our loops&mdash;hasOwnProperty doesn&rsquo;t apply to properties inherited from prototype.</i></blockquote><br/><i>(13. December 2019 12:45)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>That means we have to look at the issue from the other side&mdash;what happens to our for/in loops when someone else starts tinkering with prototype? A page can contain scripts written by multiple developers, third-party scripts from external sources, and so on&mdash;we can&rsquo;t be certain that our for/in loops won&rsquo;t be affected by unexpected enumerable properties.</i></blockquote><br/><i>(13. December 2019 12:43)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>__proto__ allows us to add, remove, and completely change how JavaScript&rsquo;s built-in properties work on any one object&mdash;and in doing so, change the set of properties and methods that are built into all related objects.</i></blockquote><br/><i>(13. December 2019 12:39)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>since pretty much everything is an object&mdash;and you can add properties to any object&mdash;that means for/in can end up iterating over properties we never meant for it to know about.</i></blockquote><br/><i>(13. December 2019 12:32)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>but just like a regular for loop gave us a number data type we could use to access our data on each iteration, for/in gives us the string we need to access the data in an object:</i></blockquote><br/><i>(13. December 2019 12:30)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 4. Loops</b><br/><blockquote><i>for/in is used to iterate over the properties of an object&mdash;but in an arbitrary order, not a sequential one.</i></blockquote><br/><i>(13. December 2019 12:29)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 3. Conditional Statements</b><br/><blockquote><i>get the idea: when case 3: matches, all the console.log statements between there and the next break statement are executed, and we get a list of days.

You&rsquo;ll also notice something new in this switch statement: a default keyword.</i></blockquote><br/><i>(13. December 2019 12:04)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 3. Conditional Statements</b><br/><blockquote><i>The break statement then says, &ldquo;We&rsquo;ve found our match, so stop comparing.&rdquo;</i></blockquote><br/><i>(13. December 2019 12:01)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 3. Conditional Statements</b><br/><blockquote><i>We don&rsquo;t need var when we assign a value to lunch, since using lunch as an argument means we&rsquo;ve already defined it as a variable local to the function.</i></blockquote><br/><i>(13. December 2019 11:57)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 3. Conditional Statements</b><br/><blockquote><i>Those aren&rsquo;t strangely consistent typos: everything in JavaScript can be coerced to a true or false Boolean value when using the non-strict comparison operator.</i></blockquote><br/><i>(13. December 2019 11:40)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 3. Conditional Statements</b><br/><blockquote><i>else is used to run alternate lines of code, in the event that the contents of an if evaluate to false</i></blockquote><br/><i>(13. December 2019 11:35)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 3. Conditional Statements</b><br/><blockquote><i>Since if blindly evaluates the contents of the two parentheses that follow it for truth, we don&rsquo;t always have to make a specific assertion there&mdash;we can use it to check a Boolean value the same way.</i></blockquote><br/><i>(13. December 2019 11:35)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 3. Conditional Statements</b><br/><blockquote><i>CONDITIONAL STATEMENTS are a type of control flow concerned with logic: they determine when and where to execute code, based on conditions you specify.</i></blockquote><br/><i>(13. December 2019 11:31)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>While we haven&apos;t used them in terribly complex ways yet, they combine to make up the entirety of JavaScript itself. From top to bottom, JavaScript is made of predefined objects that behave just like the custom ones we&rsquo;ve been defining here.</i></blockquote><br/><i>(13. December 2019 11:29)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>a function is an object that does something, rather than just holding a value.</i></blockquote><br/><i>(13. December 2019 11:23)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>Instead, we use an identifier to reference a function containing that code, and pass the function any information it needs to perform a task for us.</i></blockquote><br/><i>(13. December 2019 11:23)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>The reason bracket notation requires a string is the reason bracket notation exists at all: in complex scripts, we might need to programmatically access certain keys based on custom logic that we&rsquo;ve coded. In order to do that, we may need to put together a custom string from strings, numbers, variables, and so on</i></blockquote><br/><i>(13. December 2019 10:29)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>Once we&rsquo;ve defined an object using either of the above methods, there are two ways to access and change the information inside an object: dot notation and bracket notation.</i></blockquote><br/><i>(13. December 2019 10:28)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>Object literal notation allows us to define and assign data to an object all at once:</i></blockquote><br/><i>(13. December 2019 10:27)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>The second way is with object literal notation:

var myDog = {};</i></blockquote><br/><i>(13. December 2019 10:27)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>There are two ways to define a new object. One is with the new keyword, whose syntax shouldn&rsquo;t be entirely unfamiliar at this point:

var myDog = new Object();</i></blockquote><br/><i>(13. December 2019 10:26)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>object can contain multiple values as properties. Unlike an array that accepts a set of data types and assigns each item a numbered index, an object&rsquo;s properties are named using strings.</i></blockquote><br/><i>(13. December 2019 10:25)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>Once defined, arrays come with a number of associated methods for navigating and changing their data. For example, the .length property on an array describes the number of items in that array:</i></blockquote><br/><i>(13. December 2019 10:23)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>we can use either the bracket syntax or the  new Array() syntax to initialize an array with no defined items, just like we can initialize a variable but leave it undefined.</i></blockquote><br/><i>(13. December 2019 10:21)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>but there&rsquo;s an alternative method for initializing an array:

var myFirstArray = new Array( &quot;item1&quot;, &quot;item2&quot; );</i></blockquote><br/><i>(13. December 2019 10:20)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>JavaScript is zero-indexed, which means that JavaScript starts indexing at 0 and counts up from there.</i></blockquote><br/><i>(13. December 2019 10:19)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>Arrays aren&rsquo;t all that different from variables, with one major exception: while a variable contains a single value, an array can contain multiple values, like a list. T</i></blockquote><br/><i>(13. December 2019 10:17)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>variable defined inside a function can be either local or global, depending on how we define it&mdash;which really comes down to whether we declare it by using the keyword var. Inside a function, var declares a variable in that function&rsquo;s local scope, but omitting var means that variable should be global&mdash;in other words, exposed to the entire application.</i></blockquote><br/><i>(13. December 2019 10:16)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>A variable defined outside of a function is global.</i></blockquote><br/><i>(13. December 2019 10:16)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>Think of variable scope as the section of your source code where you&rsquo;ve assigned something an identifier. Outside of that section, that variable is not defined, and the identifier may be reused for something else</i></blockquote><br/><i>(13. December 2019 10:15)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>words that already have an immutable meaning to JavaScript, or are set aside just in case they get added to JavaScript one day:

abstract boolean break byte case catch char class const continue debugger default delete do double else enum export extends false final finally float for function goto if implements import in instanceof int interface long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var void volatile while with</i></blockquote><br/><i>(12. December 2019 19:17)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>There are a set of words in JavaScript that can&rsquo;t be used as identifiers, like null, for example. These are called keywords</i></blockquote><br/><i>(12. December 2019 19:17)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>The name we give a variable is called an identifier.

Like everything in JavaScript, identifiers are case-sensitive, and come with a few special rules, as well:

They must start with a letter, underscore, or dollar sign&mdash;not a number.
They can&rsquo;t contain spaces.
They can&rsquo;t contain special characters (! . , / \ + - * =).</i></blockquote><br/><i>(12. December 2019 19:16)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>The second method uses individual var keywords:</i></blockquote><br/><i>(12. December 2019 19:08)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>we have a couple of options for defining multiple variables, using two different but equivalent syntaxes. The first uses a single var keyword and splits the sets of variable names and assigned data with commas (ending with a semicolon, of course):</i></blockquote><br/><i>(12. December 2019 19:08)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>it&rsquo;s a good idea to always declare your variables with the var keyword even when it&apos;s not required</i></blockquote><br/><i>(12. December 2019 19:07)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 2. Understanding Data Types</b><br/><blockquote><i>Unlike a &ldquo;strongly typed&rdquo; language&mdash;which requires us to define data as a certain type&mdash;JavaScript infers the meaning from context.</i></blockquote><br/><i>(12. December 2019 17:56)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>Perhaps weirder still, line breaks are the only form of white space&mdash;which includes tabs and spaces&mdash;that has any real significance to JavaScript,</i></blockquote><br/><i>(12. December 2019 17:52)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>statement in JavaScript should almost always end in a semicolon, which is a way to tell a JavaScript parser that it has reached the end of a command, the same way a period ends a sentence in English</i></blockquote><br/><i>(12. December 2019 17:50)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>One strict rule&mdash;one that occasionally trips me up to this day&mdash;is that JavaScript is case-sensitive. That means that avariable and aVariable are treated as two completely different things.</i></blockquote><br/><i>(12. December 2019 17:48)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>This short explanation of the REPL is that it allows us to send things directly to the browser&rsquo;s JavaScript parser, without needing to update our script file and reload the page.</i></blockquote><br/><i>(12. December 2019 17:45)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>Be sure to check for any leftover debugging code like console.log before using a script on a live website, just to be safe.</i></blockquote><br/><i>(12. December 2019 17:44)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>The JavaScript console has two main functions when it comes to testing and debugging: it provides us with a place to log errors and information, and a JavaScript prompt for interacting with the page and our scripts directly.</i></blockquote><br/><i>(12. December 2019 17:39)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>You can write JavaScript into the console and execute it the same way the browser&rsquo;s JavaScript engine would if it lived in the page. T</i></blockquote><br/><i>(12. December 2019 17:39)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>These days, browsers compete on the quality of their dev tools, and we have tons of options for digging into the internals of our scripts&mdash;the simplest of which is still to send ourselves a message from inside the script, but with the potential to contain much more information than a simple string of text.</i></blockquote><br/><i>(12. December 2019 17:30)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>modern desktop browsers all come with advanced JavaScript debugging tools built in.</i></blockquote><br/><i>(12. December 2019 17:26)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>This means we&rsquo;re shifting the burden of that slight delay from the rendering of a page to the request for a script, which isn&apos;t always ideal; there are times when we might want a script to be parsed as quickly as possible, even before the DOM is available. F</i></blockquote><br/><i>(12. December 2019 17:16)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>Including too many scripts in the head can make our pages feel slow.</i></blockquote><br/><i>(12. December 2019 17:14)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Chapter 1. Getting Set Up</b><br/><blockquote><i>When it comes to JavaScript, though, we need to put a little more thought into placement, no matter whether the scripts are external or part of the page itself.</i></blockquote><br/><i>(12. December 2019 17:13)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>Having these methods built into JavaScript can lead to a little confusion over where JavaScript ends and the DOM begins, but fortunately that isn&rsquo;t something we have to worry about just yet.</i></blockquote><br/><i>(12. December 2019 17:10)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>The DOM&rsquo;s second purpose is to provide JavaScript with a set of methods and functions that allow access to the mapped nodes&mdash;</i></blockquote><br/><i>(12. December 2019 17:09)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>Every element, comment, and even snippet of text is a node.</i></blockquote><br/><i>(12. December 2019 17:09)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>The DOM serves two purposes. The first is providing JavaScript with a structured &ldquo;map&rdquo; of the page by translating our markup to a form that JavaScript (and many other languages) can understand.</i></blockquote><br/><i>(12. December 2019 17:08)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>the DOM API allows us to read, alter, and remove information from documents&mdash;to change things on the webpage itself.</i></blockquote><br/><i>(12. December 2019 17:08)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>JavaScript communicates with the contents of our pages by way of an API named the Document Object Model, or DOM</i></blockquote><br/><i>(12. December 2019 17:08)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>Times have changed, though. The same kinds of web standards efforts that brought us semantically-meaningful markup and sane CSS support have also made JavaScript&rsquo;s syntax more consistent from browser to browser, and set reasonable constraints around the parts of a browser&rsquo;s behavior it can influence.</i></blockquote><br/><i>(12. December 2019 16:42)</i><br/></p><hr/><p><span style='color:#99CF4B'><b>Green:</b></span><br/><b>Introduction</b><br/><blockquote><i>JavaScript allows us to add interaction to our pages as a complement to the structural layer that is markup and the presentational layer that is CSS.</i></blockquote><br/><i>(12. December 2019 16:37)</i><br/></p><hr/>